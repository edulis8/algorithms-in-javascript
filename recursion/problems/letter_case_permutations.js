// Letter Case Permutation
// Given a string, return all strings that can be generated by changing case of one or more letters in it.

// Example One
// {
// "s": "a1z"
// }
// Output:

// ["A1Z", "A1z", "a1Z", "a1z"]
// Example Two
// {
// "s": "123"
// }
// Output:

// ["123"]
// Notes
// Return strings in any order.

// Constraints:

// Input string may contain only: 'a'..'z', 'A'..'Z', '0'..'9'
// 1 <= length of the string <= 12

/* -------
Permutations, there are 2 choices for each blank in a slate
in first example, slate is _ _ _. 2 choices, one chioice, 2 choices.
worst case would always have 2 choices, all letters.

strategy:
lazy manager. makes one choice. Whether or not the first char should be upper or lower
  hand partial solution/slate to subordinate, along with the rest of the array/subproblem
  subordinate does the same
  leaf node worker / base case: "rest of array" is empty

will user helper func
// ------- */


/**
 * @param {str} s
 * @return {list_str}
 */
function letter_case_permutations(s) {
  const result = [];
  const helper = (slate, subproblemString) => {
    // base case
    if (subproblemString.length === 0) {
      result.push(slate);
      return;
    }
    // make choice
    // hand off partial solution and rest of string
    // if current element is a number, no choice ot make
    if (!isNaN(Number(subproblemString[0]))) {
      helper(slate + subproblemString[0], subproblemString.slice(1))
    } else {
      helper(slate + subproblemString[0].toLowerCase(), subproblemString.slice(1))
      helper(slate + subproblemString[0].toUpperCase(), subproblemString.slice(1))
    }
  }

  helper('', s);
  return result;
}

console.log('\n******************** OUTPUT ************\n');
let input = {
  "s": "a1z"
}

let result = letter_case_permutations_mutated_slate(input.s);
console.log('result:', result)
console.log('\n******************** ************\n')


// NOTE - whenever you add something to the slate, when the recursive call returns, you remove it
function letter_case_permutations_mutated_slate(s) {
  const result = [];
  const helper = (s, i, slate) => {
    // base case
    if (i === s.length) {
      result.push(slate.join(''));
      return;
    }
    // make choice
    // hand off partial solution and rest of string
    // if current element is a number, no choice ot make
    if (!isNaN(Number(s[i]))) {
      slate.push(s[i]);
      helper(s, i + 1, slate);
      // NOTE - whenever you add something to the slate, when the recursive call returns, you remove it
      slate.pop();
      // ^^^
    } else {
      slate.push(s[i].toLowerCase());
      helper(s, i + 1, slate);
      slate.pop();
      slate.push(s[i].toUpperCase());
      helper(s, i + 1, slate);
      slate.pop();
    }
  }

  helper(s, 0, []);
  return result;
}
