// TAKE TOO LONG

// WATCH LEETCODE EDITORIAL VID
https://leetcode.com/problems/decode-ways/editorial/


function decodeVariations(S) {

  //const memo = new Map(); // Memoization map
  
  let count = 0;
  const alphabet = new Set([
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26
  ])

  helper(S, 0, '') // slate -> combination

  return count;

  function helper(string, i, slate) {

    // if (memo.has(i)) {
    //   return memo.get(i);
    // }
    
    // base case
    if (i === string.length) {
      console.log(slate)
      count++;
      return;
    }

    helper(string, i + 1, slate + string[i])

    if (i + 1 < string.length) {
      const toAdd = string[i] + string[i + 1];
      if (alphabet.has(Number(toAdd))) {
        console.log('toAdd', toAdd)
        slate = slate + toAdd;
        helper(string, i + 2, toAdd)
      }
    }
  }
  // memo.set(i, ways);
}
// const input = '226'
// const result = _decodeVariations(input);
// console.log('result', result)


/**
 * 
 * The addition of memoization to the code significantly improves the time complexity by avoiding redundant calculations. 
 * Without memoization, the original recursive code has an exponential time complexity because it explores many overlapping subproblems multiple times.

With memoization, the time complexity becomes linear, specifically O(n), where "n" is the length of the input string "S." 
This is because each subproblem (i) is solved once, and the result is stored in the memo map, preventing re-computation.

The key factor in this improvement is that memoization ensures that you do not recalculate the number of ways to decode the same substring multiple times. Instead, you look up the result in the memo map, resulting in a significant reduction in time complexity for large inputs.

In summary, memoization reduces the time complexity from exponential (2^n) to linear (O(n)), making the algorithm much more efficient for large input strings.

FROM EXPONENTIAL TO LINEAR
  @param S: string
  @return: integer


  MEMOIZED, generated by Chat GPT, may contain bugs
  */
function decodeVariations(s) {
  const memo = new Map(); // Memoization map
  let count = 0;
  const alphabet = new Set([
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26
  ]);

  helper(s, 0, '');

  return count;

  function helper(string, i, slate) {
    // Check if the result is memoized
    if (memo.has(i)) {
      return memo.get(i);
    }

    // base case
    if (i === string.length) {
      count++;
      return;
    }

    let ways = 0;
    ways += helper(string, i + 1, slate + string[i]);

    if (i + 1 < string.length) {
      const toAdd = string[i] + string[i + 1];
      if (alphabet.has(Number(toAdd))) {
        slate = slate + toAdd;
        ways += helper(string, i + 2, toAdd);
      }
    }

    // Memoize the result for this index
    memo.set(i, ways);

    return ways;
  }
}

/*
input:  S = '1262'
output: 3
explanation: There are 3 messages that encode to
'1262': 'AZB', 1 26 2
 'ABFB', 1 2 6 2
'LFB', 12 6 2
*/


// a letter is 1 -> 26
// 2 digits max

// we can pick 1 digits or 2 digits

// manager
// passes subproblem to submanager
// manager makes 2 decisions
// 1 append to "slate"
// 12 append to slate
// pass rest of string to submanagers




/**
 * Deals with zeros
 * Takes too long.
 * maybe some backtracking or memoization
 */
var numDecodings = function (S) {
  /**
  @param S: string
  @return: integer
  */
  let count = 0;
  const alphabet = new Set([
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26
  ])

  helper(S, 0, '') // slate -> combination

  return count;

  function helper(string, i, slate) {
    // base case
    if (i === string.length) {
      console.log('slate', slate)
      count++;
      return;
    }

    const newSlate = slate + string[i]
    if (newSlate[0] != 0) {
      if (alphabet.has(Number(string[i]))) {
        helper(string, i + 1, slate + string[i])
      }

    }


    if (i + 1 < string.length) {
      const toAdd = string[i] + string[i + 1];
      if (alphabet.has(Number(toAdd))) {
        if (toAdd[0] != 0) {
          slate = slate + toAdd;
          helper(string, i + 2, toAdd)
        }

      }
    }
  }
}
const input = '11111'
const result = numDecodings(input);
console.log('result', result)

/*
input:  S = '1262'
output: 3
explanation: There are 3 messages that encode to
'1262': 'AZB', 1 26 2
 'ABFB', 1 2 6 2
'LFB', 12 6 2
*/


// a letter is 1 -> 26
// 2 digits max

// we can pick 1 digits or 2 digits

// manager
// passes subproblem to submanager
// manager makes 2 decisions
// 1 append to "slate"
// 12 append to slate
// pass rest of string to submanagers   


// 1262


alphabet = {
   '1':
   '2':
   '3':
   '4':
   '5':
   '6':
   '7':
   '8':
   '9':
   '10':
   '11':
   '12':
   '13':
   '14':
   '15':
   '16':
   '17':
   '18':
   '19':
   '20':
   '21':
   '22':
   '23':
   '24':
   '25':
   '26':
}












// N = 4
// dp = [-,-,1,1]
